name: Docker

on:
  workflow_dispatch:
  push:
    branches: [ master ]


env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"

jobs:

  build:
    name: Pull
    runs-on: ubuntu-latest
    steps:
    - name: Docker Setup Buildx
      uses: docker/setup-buildx-action@v3

    - name: Checkout Code
      uses: actions/checkout@v4

	- name: Build and push image Aliyun
	  run: |
	    set -e  # 执行出错立即终止，方便定位问题
	    docker login -u $ALIYUN_REGISTRY_USER -p $ALIYUN_REGISTRY_PASSWORD $ALIYUN_REGISTRY
	    
	    # 调试：输出关键变量（GitHub会掩码secrets，但能确认变量是否存在）
	    echo "ALIYUN_REGISTRY: $ALIYUN_REGISTRY"
	    echo "ALIYUN_NAME_SPACE: $ALIYUN_NAME_SPACE"
	    
	    # 数据预处理,判断镜像是否重名
	    declare -A duplicate_images
	    declare -A temp_map
	    while IFS= read -r line; do
	        # 忽略空行与注释
	        [[ -z "$line" ]] && continue
	        [[ "$line" =~ ^[[:space:]]*# ]] && continue
	        
	        # 提取镜像核心名称（剔除--platform等参数，只取最后一段）
	        # 处理格式：--platform linux/amd64 nacos/nacos-server:latest 或直接 nacos/nacos-server:latest
	        image=$(echo "$line" | awk '{print $NF}')
	        # 移除@sha256摘要（避免影响标签解析）
	        image_clean="${image%%@*}"
	        echo "原始镜像名: $image | 清理后: $image_clean"
	        
	        # ========== 修复：正确切割命名空间/镜像名/标签 ==========
	        # 拆分镜像为「仓库前缀」和「镜像名:标签」（处理 docker.io/nginx、nacos/nacos-server、nginx 三种情况）
	        if [[ "$image_clean" =~ / ]]; then
	            # 有命名空间的情况：nacos/nacos-server:latest → 命名空间nacos，镜像名nacos-server:latest
	            name_space_part="${image_clean%/*}"  # 取最后一个/前面的部分（nacos 或 docker.io）
	            image_name_tag="${image_clean##*/}" # 取最后一个/后面的部分（nacos-server:latest）
	        else
	            # 无命名空间的情况：nginx:latest → 命名空间空，镜像名nginx:latest
	            name_space_part=""
	            image_name_tag="$image_clean"
	        fi
	        # 拆分镜像名和标签（nacos-server:latest → 镜像名nacos-server，标签latest）
	        image_name="${image_name_tag%:*}"      # 镜像名（不含标签）
	        image_tag="${image_name_tag#*:}"       # 标签（如果无:，则等于image_name_tag）
	        # 处理无标签的情况（如 nginx → 标签默认latest）
	        [[ "$image_tag" == "$image_name_tag" ]] && image_tag="latest"
	        
	        echo "命名空间: $name_space_part | 镜像名: $image_name | 标签: $image_tag"
	        
	        # ========== 修复：重名判断逻辑（去掉多余的_） ==========
	        if [[ -n "${temp_map[$image_name]}" ]]; then
	            # 已存在同名镜像，判断命名空间是否不同
	            if [[ "${temp_map[$image_name]}" != "$name_space_part" ]]; then
	                echo "⚠️ 镜像名重名：$image_name（命名空间分别为 ${temp_map[$image_name]} 和 $name_space_part）"
	                duplicate_images[$image_name]="true"
	            fi
	        else
	            temp_map[$image_name]="$name_space_part"
	        fi       
	    done < images.txt
	    
	    # 遍历拉取、打标签、推送镜像
	    while IFS= read -r line; do
	        [[ -z "$line" ]] && continue
	        [[ "$line" =~ ^[[:space:]]*# ]] && continue
	        
	        echo "===== 处理镜像：$line ====="
	        # 拉取镜像
	        docker pull "$line"
	        
	        # 提取平台信息（处理 --platform linux/amd64 格式）
	        platform=$(echo "$line" | grep -o '--platform [^ ]*' | awk '{print $2}')
	        echo "平台信息: $platform"
	        # 平台前缀（替换/为_，如 linux/amd64 → linux_amd64_）
	        platform_prefix=""
	        if [[ -n "$platform" ]]; then
	            platform_prefix="${platform//\//_}_"
	        fi
	        
	        # ========== 复用上面的切割逻辑，提取命名空间/镜像名/标签 ==========
	        image=$(echo "$line" | awk '{print $NF}')
	        image_clean="${image%%@*}"
	        if [[ "$image_clean" =~ / ]]; then
	            name_space_part="${image_clean%/*}"
	            image_name_tag="${image_clean##*/}"
	        else
	            name_space_part=""
	            image_name_tag="$image_clean"
	        fi
	        image_name="${image_name_tag%:*}"
	        image_tag="${image_name_tag#*:}"
	        [[ "$image_tag" == "$image_name_tag" ]] && image_tag="latest"
	        
	        # ========== 修复：重名时的命名空间前缀 ==========
	        name_space_prefix=""
	        if [[ -n "${duplicate_images[$image_name]}" && -n "$name_space_part" ]]; then
	            name_space_prefix="${name_space_part}_"
	        fi
	        
	        # 拼接新镜像名（核心：避免空值导致的//）
	        new_image="${ALIYUN_REGISTRY}/${ALIYUN_NAME_SPACE}/${platform_prefix}${name_space_prefix}${image_name}:${image_tag}"
	        echo "最终镜像名: $new_image"
	        
	        # 打标签并推送
	        docker tag "$image_clean" "$new_image"
	        docker push "$new_image"
	        echo "✅ 推送成功：$new_image"
	    done < images.txt
